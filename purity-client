#!/usr/bin/env python
#
# ToonLoop for Python
#
# Copyright 2008 Alexandre Quessy & Tristan Matthews
# <alexandre@quessy.net> & <le.businessman@gmail.com>
# http://www.toonloop.com
#
# ToonLoop is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ToonLoop is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the gnu general public license
# along with ToonLoop.  If not, see <http://www.gnu.org/licenses/>.
#
"""
Simpler FUDI sender.

TODO: port 5400 + n
"""
import random
from twisted.internet import reactor
from optparse import OptionParser
from rats import fudi
from rats.purity.obj import get_main_patch

class PurityClient(object):
    """
    Dynaminc patching Pure Data message sender.
    Used for dynamic patching with Pd.
    """
    def __init__(self, receive_port=14444, send_port = 15555, use_tcp=True, quit=quit):
        self.send_port = send_port
        self.receive_port = receive_port
        self.client_protocol = None
        self.fudi_server = None
        self.use_tcp = use_tcp # TODO
        self.quit = quit

    def server_start(self):
        """ returns server """
        self.fudi_server = fudi.FUDIServerFactory()
        self.fudi_server.register_message("pong", self.pong)
        reactor.listenTCP(self.receive_port, self.fudi_server)
        return self.fudi_server

    def client_start(self):
        """ 
        Starts sender. 
        returns deferred """
        self.client_protocol = None
        print("Starting FUDI client sending to %d" % (self.send_port))
        deferred = fudi.create_FUDI_client('localhost', self.send_port, self.use_tcp)
        deferred.addCallback(self.on_client_connected)
        deferred.addErrback(self.on_client_error)
        return deferred

    def pong(self, protocol, *args):
        """ Receives FUDI pong """
        print "received pong", args
        # print("stopping reactor")
        # reactor.stop()

    def on_client_connected(self, protocol):
        """ Client can send messages to Pure Data """
        self.client_protocol = protocol
        # self.client_protocol.send_message("ping", 1, 2.0, "bang")
        # print "sent ping"

    def on_client_error(self, failure):
        """ Client cannot send data to pd """
        print "Error trying to connect.", failure
        raise Exception("Could not connect to pd.... Dying.")
        # print "stop"
        # reactor.stop()


    def send_message(self, selector, *args):
        """ Send a message to pure data """
        if self.client_protocol is not None:
            # if fudi.VERBOSE:
            # print("sending %s" % (str(args)))
            # print args[0], args[1:]
            # args = list(args[1:])
            # atom = args[0]
            # print("will send %s %s" % (selector, args))
            self.client_protocol.send_message(selector, *args)
        else:
            print("Could not send %s" % (str(args)))
        if self.quit:
            print "stopping the application"
            # TODO: try/catch
            reactor.callLater(0, reactor.stop)

if __name__ == "__main__":        
    def test_message(purityclient):
        purityclient.send_message("pd-main", "clear")
        purityclient.send_message("pd-main", "obj", 50, 50, "tgl", 60)
        purityclient.send_message("pd-main", "obj", 100, 100, "metro", 60)
        purityclient.send_message("pd-main", "connect", 0, 0, 1, 0)

    def other_test(purityclient):
        """
        [r startme] --> [tgl] --> [metro 500] --> [bng]
        """
        main = get_main_patch()
        # subpatch
        patch = main.subpatch("metropatch")
        # objects
        r = patch.receive("startme")
        tgl = patch.obj("tgl")
        metro = patch.obj("metro", 500)
        bang = patch.obj("bng")
        # connections
        patch.connect(r, 0, tgl, 0)
        patch.connect(tgl, 0, metro, 0)
        patch.connect(metro, 0, bang, 0)
        # send messages
        mess_list = main.get_fudi() # list of (fudi) lists
        # print(mess_list)
        for mess in mess_list:
            purityclient.send_message(*mess)
            message = fudi.to_fudi(*mess)
            print "sent FUDI message:", message
        print "sent FUDI message:", "startme", 1
        purityclient.send_message("startme", 1)

    def start_server():
        #TODO: listen server
        # deferred = purityclient.server_start()
        other_deferred = purityclient.client_start()  # use_tcp)
        #other_deferred.addCallback(purityclient.send_message, "obj", 100, 100, "metro", 60)
    
    def audio_test(purityclient):
        """
        [r sine] --> [line~] --> [osc~] --> [*~ 0.25] --> [dac~]
        """
        main = get_main_patch()
        patch = main.subpatch("sinepatch")
        # objects
        r = patch.receive("sine")
        line = patch.obj("line~")
        osc = patch.obj("osc~", 440)
        mult = patch.obj("*~", 0.125)
        dac = patch.obj("dac~")
        # connections
        patch.connect(r, 0, line, 0)
        patch.connect(line, 0, osc, 0)
        patch.connect(osc, 0, mult, 0)
        patch.connect(mult, 0, dac, 0)
        patch.connect(mult, 0, dac, 1) # stereo

        def start_audio(purityclient):
            purityclient.send_message("pd", "dsp", 1)
        def send_random_note(purityclient, send_random_note):
            note = random.randint(220, 880)
            delay = 500
            purityclient.send_message("sine", note, delay) # ms
            reactor.callLater(delay / 1000., send_random_note, purityclient, send_random_note)
        # send messages
        mess_list = main.get_fudi() # list of (fudi) lists
        # print(mess_list)
        for mess in mess_list:
            purityclient.send_message(*mess)
        reactor.callLater(0.1, start_audio, purityclient)
        reactor.callLater(0.1, send_random_note, purityclient, send_random_note)

    def stop_all(purityclient):
        print "stopping"
        mess = ["pd", "quit"]
        purityclient.send_message(*mess)
        reactor.stop()

    # -----------------------------------------------
    parser = OptionParser(usage="%prog options message...")
    parser.add_option("-s", "--send-port", type="int", \
        help="FUDI Send port.", default=17777)
    parser.add_option("-r", "--receive-port", type="int", \
        help="FUDI Receive port.", default=15555)
    parser.add_option("-t", "--tcp", action="store_true", \
        help="Uses TCP instead of UDP.")
    parser.add_option("-v", "--verbose", action="store_true", \
        help="Sets the output to verbose.")
    parser.add_option("-q", "--quit", action="store_true", \
        help="Quits right after sending message.")
    (options, args) = parser.parse_args()
    use_tcp = not options.tcp

    fudi.VERBOSE = options.verbose
    purityclient = PurityClient(
        receive_port=options.receive_port, 
        send_port=options.send_port, 
        quit=options.quit, 
        use_tcp=True
        )
    deferred = purityclient.client_start()
    #reactor.callLater(0.01, test_message, purityclient)
    reactor.callLater(0.1, other_test, purityclient)
    reactor.callLater(0.2, audio_test, purityclient)
    reactor.callLater(10, stop_all, purityclient)
    print "will stop in 10 seconds"
    try:
        reactor.run()
    except KeyboardInterrupt, e:
        print "quit"

