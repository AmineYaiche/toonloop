#!/usr/bin/env python
"""
GLSL shaders with SDL, OpenGL texture and Python
"""
from pygame.locals import *
from OpenGL.GL import *
from OpenGL.error import GLError
from OpenGL.GLU import *
from rats.glsl import ShaderProgram
from rats.glsl import ShaderError

# # ---------------------------- module variables ----------------------------
# 
# # ---------------------------- glsl vertex shader ----------------------------
# vert = """
# /**
#  * Vertex shader that does nothing
#  */
# // variables passed to the fragment shader
# varying vec2 texcoord0;
# varying vec2 texdim0;
# 
# void main()
# {
#     gl_Position = ftransform();
#     texcoord0 = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);
#     texdim0 = vec2(abs(gl_TextureMatrix[0][0][0]), abs(gl_TextureMatrix[0][1][1]));
# }
# """
# 
# # ---------------------------- glsl fragment shader ----------------------------
# frag = """
# /**
#  * Fragment shader for chroma-keying. 
#  * 
#  * (using a green or blue screen, or any background color)
#  * 
#  * Main thing is, make sure the texcoord's arent 
#  * normalized (so they are in the range of [0..w, 0..h] )
#  * 
#  * All params are vec3 in the range [0.0, 1.0]
#  * 
#  * :param keying_color: The RGB keying color that will be made transparent.
#  * :param thresh: The distance from the color for a pixel to disappear.
#  * 
#  * :author: Alexandre Quessy <alexandre@quessy.net> 2009
#  * :license: GNU Public License version 3
#  * 
#  *  smoothstep with distance from target color
#  *  genType smoothStep(genType edge0, genType edge1, genType x);
#  *  The result will be zero if x <= edge0, 1 
#  *  if x >= edge1 and performs smooth Hermite interpolation 
#  *  between 0 and 1 when edge0 < x < edge1. 
#  */
# 
# // user-configurable variables (read-only)
# uniform vec3 keying_color;
# uniform float thresh; // [0, 1.732]
# uniform float slope; // [0, 1]
# 
# // the texture
# uniform sampler2DRect image;
# 
# // data passed from vertex shader:
# varying vec2 texcoord0;
# varying vec2 texdim0;
# 
# void main(void)
# {
#     // sample from the texture 
#     vec3 input_color = texture2DRect(image, texcoord0).rgb;
# 
#     float d = abs(length(abs(keying_color.rgb - input_color.rgb)));
#     float edge0 = thresh * (1.0 - slope); 
#     float alpha = smoothstep(edge0, thresh, d);
#     gl_FragColor = vec4(input_color, alpha); 
# }
# """
# #//float d = distance(input_color.rgb, keying_color.rgb);
# #// float input_alpha = gl_Color.a; // used to be 1.0;
# #// max(thresh - slope, 0.0); // if slope==0 edge0=thresh
# # // float output_alpha = alpha; //  * input_alpha;
# # 
# # uniform float alpha_result;
# #     // measure distance from keying_color
# #     vec3 delta = abs(input_color - keying_color);
# # 	
# # 	// for now, not visible if under threshold of proximity
# # 	// TODO: mix() according the 3 factors of proximity.
# # 	if (delta.r <= thresh.r && delta.g <= thresh.g && delta.b <= thresh.b)
# # 	{
# # 	   output_alpha = alpha_result; // 0.0
# # 	}
# #     gl_FragColor = vec4(input_color, output_alpha); 
# # }
# # """
# # ----------------------------  functions ----------------------------
# class TestEffect(object):
#     def __init__(self):
#         self.program = None
#         self.loaded = False
#         self.enabled = False
#         self.config = {
#             'chromakey_r':0.2,
#             'chromakey_g':0.8,
#             'chromakey_b':0.0,
#             'chromakey_thresh':0.8,
#             'chromakey_slope':0.2,
#             'texture_id':0,
#             }
#         
#     def setup(self):
#         global vert
#         global frag
#         try:
#             self.program = ShaderProgram()
#             self.program.add_shader_text(GL_VERTEX_SHADER_ARB, vert)
#             self.program.add_shader_text(GL_FRAGMENT_SHADER_ARB, frag)
#             self.program.linkShaders()
#             self.loaded = True
#         except GLError, e:
#             print(str(e))
#         except Exception, e: 
#             print e.message
#     
#     def pre_draw(self):
#         if self.enabled and self.loaded:
#             try:
#                 self.program.enable()
#             except Exception, e: 
#                 print e.message
#             self.program.glUniform1i("image", self.config.texture_id) # XXX: need to pass the texture ID !!
#             # program.glUniform1f("alpha_result", 0.2)
#             self.program.glUniform3f(
#                 "keying_color", 
#                 self.config['chromakey_r'], 
#                 self.config['chromakey_g'], 
#                 self.config['chromakey_b'])
#             self.program.glUniform1f("thresh", self.config['chromakey_thresh'])
#             self.program.glUniform1f("slope", self.config['chromakey_slope'])
#         #     print 'color:%s %s %s, thresh:%s, slope:%s' % (config['chromakey_r'], config['chromakey_g'], config['chromakey_b'], thresh, slope)
# 
#     def post_draw(self):
#         if self.enabled and self.loaded:
#             try:
#                 self.program.disable()
#             except Exception, e: 
#                 print e.message
# 
# ----------------------------  main  ----------------------------
import os
import sys
import pygame
import pygame.image
import pygame.camera

# ----------------------------  classes  ----------------------------
class VideoCapturePlayer(object):
    size = (640, 480)
    def __init__(self, effect):
        self.effect = effect
        self.textures = [0] # list of texture ID 

        # create a display surface. standard pygame stuff
        self.screen = pygame.display.set_mode(self.size, OPENGL | DOUBLEBUF | HWSURFACE)
        pygame.display.set_caption("Shader Tester")
        self.resize(self.size)
        self.gl_init()
        # gets a list of available cameras.
        self.clist = pygame.camera.list_cameras()
        if not self.clist:
            raise ValueError("Sorry, no cameras detected.")
        if os.uname()[0] == 'Darwin':
            self.isMac = True
            # creates the camera of the specified size and in RGB colorspace
            self.camera = pygame.camera.Camera(0, self.size, 'RGBA')
        else:
            self.isMac = False
            # creates the camera of the specified size and in RGB colorspace
            self.camera = pygame.camera.Camera('/dev/video0', self.size, "RGBA")
        # starts the camera
        self.camera.start()
        self.clock = pygame.time.Clock()

        # create a surface to capture to.  for performance purposes, you want the
        # bit depth to be the same as that of the display surface.
        self.snapshot = pygame.surface.Surface(self.size, 0, self.screen)

    def gl_init(self):
        """
        Init the window
        """
        glEnable(GL_TEXTURE_RECTANGLE_ARB) 
        print("Enabled GL_TEXTURE_RECTANGLE_ARB")
        glShadeModel(GL_SMOOTH)
        self.textures[0] = glGenTextures(1)
        glClearColor(0.0, 0.0, 0.0, 0.0)
        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        glColor3f(1., 1., 1.)
        print("will setup effect")
        try:
            self.effect.setup()
        except GLError, e:
            print(str(e)) # should fully format it
            print(e.description)
    
    def resize(self, (width, height)):
        """
        Called when we resize the window.
        (fullscreen on/off)
        """
        if height == 0:
            height = 1
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        glOrtho(-4.0, 4.0, -3.0, 3.0, -1.0, 1.0)
        glMatrixMode(GL_MODELVIEW)
    
    def draw(self):
        """
        Called on every frame rendering
        """
        w = 640.0
        h = 480.0
        aspectRatio = w / float(h)

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        self.effect.pre_draw()
        
        glPushMatrix()
        glBegin(GL_QUADS)
        glTexCoord2f(0.0, 0.0)
        glVertex2f(-4.0, -3.0) # Bottom Left
        glTexCoord2f(w, 0.0)
        glVertex2f(4.0, -3.0) # Bottom Right
        glTexCoord2f(w, h)
        glVertex2f(4.0, 3.0) # Top Right
        glTexCoord2f(0.0, h)
        glVertex2f(-4.0, 3.0) # Top Left
        glEnd()
        glPopMatrix()
        
        self.effect.post_draw()

        glPushMatrix()
        glTranslate(2, 1.5, 0)
        glBegin(GL_QUADS)
        glTexCoord2f(0.0, 0.0)
        glVertex2f(-aspectRatio, -1.) # Bottom Left
        glTexCoord2f(w, 0.0)
        glVertex2f(aspectRatio, -1.) # Bottom Right
        glTexCoord2f(w, h)
        glVertex2f(aspectRatio, 1.) # Top Right
        glTexCoord2f(0.0, h)
        glVertex2f(-aspectRatio, 1.) # Top Left
        glEnd()
        glPopMatrix()
    
    def get_and_flip(self):
        """
        Grabs a frame from the camera (to a texture) and renders the screen.

        if you don't want to tie the framerate to the camera, you can check and
        see if the camera has an image ready.  note that while this works
        on most cameras, some will never return true.
        """
        if 0 and self.camera.query_image():
            self.snapshot = self.camera.get_image(self.snapshot)
        self.snapshot = self.camera.get_image(self.snapshot)
        textureData = pygame.image.tostring(self.snapshot, "RGBX", 1)
        if bool(glActiveTexture):   # make sure glActiveTexture is defined
            glActiveTexture(GL_TEXTURE0) # IMPORTANT ! sets the texture unit to 0. 
        glBindTexture(GL_TEXTURE_RECTANGLE_ARB, self.textures[0])
        glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, self.snapshot.get_width(), self.snapshot.get_height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, textureData)
        glTexParameterf(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
        glTexParameterf(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
        self.draw()
        pygame.display.flip()
    
    def main(self):
        going = True
        while going:
            events = pygame.event.get()
            for e in events:
                if e.type == QUIT:
                    going = False
                if e.type == KEYDOWN:
                    if e.key == K_ESCAPE:
                        going = False
                    elif e.key == K_RETURN:
                        effect.enabled != effect.enabled
                elif e.type == KEYDOWN:
                    if e.key == K_f:
                        pygame.display.toggle_fullscreen()

            self.get_and_flip()
            self.clock.tick(30)
            #print "FPS:", self.clock.get_fps()
    
if __name__ == '__main__':
    from toon.effects import simplechroma
    effect = simplechroma.create_effect()
    effect.enabled = True # choose it !
    pygame.init()
    pygame.camera.init()
    VideoCapturePlayer(effect).main()
    pygame.quit()

